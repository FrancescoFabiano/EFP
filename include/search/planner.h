/**
 * \class planner
 * 
 * \brief Templatic class that implements several search techniques (BFS, DFS, Best-First Search) and ML dataset generation.
 *
 * The class is templatic to allow searching with different state representations.
 *
 * \todo Templatic with priority queue for heuristic search?.
 *
 * \copyright GNU Public License.
 *
 * \author Francesco Fabiano.
 * \date Originally May 6, 2019, updated April 27, 2025
 */
#pragma once

#include <queue>
#include <stack>
#include <vector>
#include <thread>
#include <mutex>
#include <set>
#include <sstream>
#include <fstream>
#include <chrono>
#include <ctime>
#include <stdlib.h>
#include <sys/wait.h>
#include <pthread.h>
#include <unistd.h>
#include <random>
// Create the random engine and distribution ONCE (global or inside a class)
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_real_distribution<> dis(0.0, 1.0);


#include "../domain/domain.h"
#include "../heuristics/heuristics_manager.h"
// Because planner is templated, and state_T is a dependency:
#include "../states/state_T.ipp"


/** \brief Class used as comparator for the priority queue (for Best-First Search). */
template <class T>
struct compare_heuristic
{
    bool operator()(const T& state1, const T& state2)
    {
        return state1.get_heuristic_value() > state2.get_heuristic_value();
    }
};

template <class T>
class planner
{
private:
    /** Queue for BFS search. */
    std::queue<T> m_search_space;

    /** Priority queue for heuristic search. */
    std::priority_queue<T, std::vector<T>, compare_heuristic<T>> m_heur_search_space;

    /** Stack for DFS search. */
    std::stack<T> m_search_space_DFS;

    /** Mutex for protecting global ML dataset. */
    std::set<T> m_visited_states_ML;

    std::map<T,int> m_states_scores;

    int m_current_nodes_ML = 0;
    int m_threshold_node_generation_ML = 25000; //Actual value of final nodes no matter what
    double m_threshold_node_generation_log_ML = std::log(m_threshold_node_generation_ML*3); // times 3 to allow for some room given the action executability as this is just use as criteron on what start proabilistics prune
    int m_total_possible_nodes_log_ML; //Possible nodes generated by the complete DFS
    bool m_goal_recently_found_ML = false;

    /** Function that searches on m_search_space using BFS.
     * 
     * @param[in] results_file Whether to print results to a file.
     * @param[in] ptype Type of parallelism to use.
     * @return true if a plan is found.
     */
    bool search_BFS(bool results_file, parallel_type ptype = P_SERIAL);

    /** Function that searches on m_search_space_DFS using DFS. */
    bool search_DFS(bool results_file, parallel_type ptype = P_SERIAL);

    /** Function that searches using Iterative Deepening DFS (IDFS). */
    bool search_IterativeDFS(bool results_file, short maxDepth, short step, parallel_type ptype = P_SERIAL);

    /** Function that searches on m_search_space using Best-First Search. */
    bool search_heur(bool results_file, heuristics used_heur, parallel_type ptype = P_SERIAL);

    /** Function to execute search in parallel using threads or processes. */
    bool parallel_search(bool results_file, parallel_input pin, heuristics used_heur, search_type used_search, short IDFS_d, short IDFS_s);

    /** Internal function to create a dataset for ML heuristics training. */
    bool ML_dataset_creation(ML_Dataset_Params* ML_dataset);

    /** Launches the dataset generation by DFS or BFS. */
    bool dataset_launcher(const std::string& fpath, int max_depth, bool useDFS, const std::string& goal_str);

    /** Serial DFS dataset generation worker. */
    bool dataset_DFS_serial(T& initial_state, int max_depth, action_set* actions, const std::string& goal_str, std::vector<std::string>& global_dataset, bool bisimulation);

    /** DFS recursive worker to explore states for dataset generation. */
    int dataset_DFS_worker(T& state, int depth, int max_depth, action_set* actions, const std::string& goal_str, std::vector<std::string>& local_dataset, bool bisimulation);

    /** Formats a single row of the dataset CSV file. */
    std::string format_row(T& state, int depth, int score, const std::string& goal_str);

public:
    /** Launches the search process based on given parameters. */
    bool search(bool results_file, parallel_input pin, heuristics used_heur, search_type used_search, ML_Dataset_Params generate_heur_ML_data, short IDFS_d, short IDFS_s);

    /** Prints search results including time and expanded nodes. */
    void print_results(std::chrono::duration<double> elapsed_seconds, int expanded_nodes, T goal, bool results_file, bool givenplan, search_type used_search, heuristics used_heur = NO_H, parallel_type ptype = P_SERIAL);

    /** Executes a given sequence of actions on the initial state. */
    void execute_given_actions(std::vector<std::string>& act_name);

    /** Executes given actions while measuring execution time. */
    void execute_given_actions_timed(std::vector<std::string>& act_name, parallel_type ptype = P_SERIAL);

    /** Checks the validity of given action names and removes duplicates. */
    void check_actions_names(std::vector<std::string>& act_name);
};


